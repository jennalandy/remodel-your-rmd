---
title: "Remodel Your Rmd"
subtitle: "Utilizing Rmd and Rstudio in Industry and Academia"
author: "Jenna Landy"
output: 
  rmdformats::robobook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{css, echo = FALSE}
.book {
  padding-top: 40px
}
```

Through my experiences in industry and academia, I’ve learned that a lot of cool things can be done with R and RStudio. Even though they often intimidated me at first, they always ended up being intuitive, well documented, and very useful to my R workflow. In this tutorial I’ll go through how I’ve “remodeled my Rmd”--and how you can do the same--by developing simple R packages for research projects, parameterizing R Markdowns for modular reports, making pretty R Markdowns, and publishing to R Markdown websites and Shiny Apps.

Topics Covered:

- R Package Development
- Parameterized Rmd Reports
- Rmd Customizations
- Interactive Plots
- Publishing R Markdown Websites with Github Pages

## Version 1: Your Basic Rmd

For demonstrations sake, we're going to start with `Version1.Rmd` and remodel it step by step. This very simple Rmd looks at the iris dataset, performs some data manipulation, and shows some plots.

Until very recently, every Rmd I made looked a little like Version 1. I would have some text, some code, and knit it using the default everything. The plots may look reasonably nice, and the code may work, but it's not the best Rmd it could be. The following tips and tricks will be especially useful if you need to use the functions defined in your Rmd in other files or on other people's computers, if you need to recompile your Rmd with different subsets of the data or with some additional pre-processing, if you need to share your results with collaborators who may or may not code, or if you'd like to publish your results publicly.

# R Package Development
**Why a package?**

1. Consolidating functions and constants used for a given research project
2. Roxygen to look up your functions documentation later (`?my_function`)
3. Unit testing
4. Easy interplay with version control (git/GitHub) for collaboration and sharing

We're going to start by focusing on the scenario where you need to use the functions defined in your Rmd in other files or on other people's computers. My old solution to this was to use one Rproject for every project I worked on, so I could source functions from Rscripts. This worked well, but then my research got bigger, and I wanted to have separate Rprojects for different aspects: testing my work on simulation studies, testing my work on real data, etc. Also, I found myself needing to use functions that I had written so long ago that I didn't know what file it was defined in and had to look deep into the code to remember what each parameter did. Some of this might've just been me having messy code, but no matter how clean your code is, consolidating it into an R package can make your life a little easier.

As a demonstration, I'll go through the steps to develop the very simple `irisproject` R package. This package will create functions for each of the data manipulation steps done in `Version1.Rmd`. This would be useful if the researcher wanted to be able to perform the same data manipulation steps in other Rmds or scripts, if they wanted to add unit tests for each function, if they wanted to collaborate on these functions over GitHub (though they might not necessarily want to share their Rmd), or if they wanted these functions to be publicly a avilable as an R package.

## Basic Steps

1. File > New Project
2. Select directory, then that you want to create an R package
3. Set package name > Create Project
```{r out.width = '40%', fig.align = 'center'}
knitr::include_graphics("images/rpackage-1.png")
```


4. Create an Rscript in the `R/` directory and add functions and/or constants
```{r out.width = '50%', fig.align = 'center'}
knitr::include_graphics("images/rpackage-2.png")
```

5. Build your package with `devtools::build()`, or navigate to the Build pane and More > Clean and Rebuild
```{r out.width = '40%', fig.align = 'center'}
knitr::include_graphics("images/rpackage-3.png")
```

Now your package is ready to use!

## Version 2: Using Your R Package

Now in `Version2.Rmd` we can load our `irispackage` and use the functions from the package for the data manipulation steps. The first time you use your package, you'll need to run `install.packages`, but after that is done once you'll run `update.packages` to make sure you load the latest version.

```{r eval = F, echo = T}
install.packages(
  "./irisproject/",
  repos=NULL,
  type="source"
)

library(irisproject)
```

## Improving Your R Package

### Roxygen documentation 
   With your curser inside of a function, navigate to Code > Insert Roxygen Skeleton. This will give the outline for documentation that you can fill in with your function's description, parameter descriptions, what is returned, and examples. You can also choose to export the function (i.e. allow it to be accessed when someone loads the package) or not (i.e. keep private or helper functions hidden).  
```{r out.width = '60%', fig.align = 'center'}
knitr::include_graphics("images/rpackage-4.png")
```   
   Once the Roxygen skeletons are filled in, you can run `devtools::document()` to build the documentation `man/` files. Rebuild the package once more after this, and then you should be able to see the documentation with `?my_function`.  
```{r out.width = '30%', fig.align = 'center'}
knitr::include_graphics("images/rpackage-5.png")
```   
 
### Unit tests 
  The unit tests are run using the `testthat` package. The tests are stored in the `tests/testthat` folder. New tests can be added to the existing test files, or a new file can be created manually or with `usethis::use_test('testname')`.  
```{r out.width = '40%', fig.align = 'center'}
knitr::include_graphics("images/rpackage-6.png")
```
  There are many of these `expect_` functions, including inequalities like `expect_gt()` (greater than), logic checks like `expect_true()`, and side-effect checks like `expect_error()`. A full list of these functions can be found in the [`testthat` Documentation](https://testthat.r-lib.org/reference/).  
  To run the unit tests, navigate to the Build pane, and click More > Test Package. The pane will update to show you the results of your tests.
```{r out.width = '40%', fig.align = 'center'}
knitr::include_graphics("images/rpackage-7.png")
```   

### Upload to GitHub

## Tips

- If you update the package source code, rebuild it.
- If you have another R session open, you need to restart R and `update.packages` before you can use the most recent version of the package.
- If you use functions from other packages inside your package, it needs to be noted in the `NAMESPACE` and `DESCRIPTION` files. Rather than doing this manually:  
  - In the Roxygen documentation of your function that uses the package, add a line `@importFrom package function1 function2 ....`. This will update the NAMESPACE when documentation is updated.
  - Run `usethis::use_package('package')` in the console. This will update the DESCRIPTION file, which checks these dependencies upon package installation.

# Parameterized Rmd Reports
**Why parameterize?**

1. You can recompile your Rmd with different specifications without changing your code, for example:
    - Specify input file
    - Working with different subsets of data (specific time period, subset of groups, excluding outliers, etc.)  
    - Options for additional pre-processing
    - Options for what variables, models, plots, etc. to include
2. Non-coding collaborators can compile their own report with specifications using the user interface instead of looking at code

Now we're thinking about whether we may want to re-compile an Rmd with new data, new options, new reprocessing steps, etc. The obvious solution is to change your code and knit the Rmd again. But what if you want to go back to the old settings? What if you want a third set of settings? A forth? Changing the code can get tedious very quickly. Also, a collaborator who may not know how to code might want to re-knit your Rmd with an updated data file or their own specifications. This is a case for parameterized R markdown files!

Parameters can be specified in the YAML header of an Rmd file. These can be standard R types, like strings and booleans, or R objects expressed with a `!r` prefix.

## Version 3: Parameterize Your Rmd

In `Version3.Rmd`, you'll see  the first change on line 4 of the notebook: adding the `params` option to the YAML header. For the iris analysis example, we'll parameterized the location of the project's package, the option to convert inches to centimeters, and what variables to include in the pairs plot.

```{r out.width = '70%', fig.align = 'center'}
knitr::include_graphics("images/parameterized-1.png")
```  

Within the code, when we want to access these parameters, we refer to them as a value within the `params` list with the `params$` prefix:

```{r eval = FALSE, echo = TRUE}
params$package_location
```

If you knit the file with the Knit button, the parameters specified in the YAML will be used. Alternatively, you can specify parameters programmatically with:

```{r eval = FALSE, echo = TRUE}
rmarkdown::render(
  "Version3.Rmd",
  params = list(
    package_location = "./irisproject",
    convert_cm = FALSE,
    plot_pairs_of = c("Sepal.Length","Species")
  )
)
```

You can also click Knit > Knit with Parameters, and a user interface will pop up to allow you to change the standard R type parameters in a way that doesn't require coding knowledge:

```{r out.width = '30%', fig.align = 'center'}
knitr::include_graphics("images/parameterized-2.png")
```  


```{r out.width = '60%', fig.align = 'center'}
knitr::include_graphics("images/parameterized-3.png")
```  

## Improving Your Parameterization

### 1. Make user interface more intuitive for non-coding collaborators  
In the image above, we see that this user interface isn't as pretty as it could be. Further, we can't change the `plot_pairs_of` in the user interface because it is an R object. We can add additional specifications `label` and `value` in the YAML header that will make the user interface more intuitive. We can also change the `plot_pairs_of` variable to a string of comma-separated variable names, and deal with converting it to a list in the code later. This last step may not be necessary if you're parameterizing an Rmd for yourself, but it can be useful if someone who doesnt know R may be using it later.  
```{r out.width = '50%', fig.align = 'center'}
knitr::include_graphics("images/parameterized-4.png")
```  
```{r out.width = '60%', fig.align = 'center'}
knitr::include_graphics("images/parameterized-5.png")
```  

### 2. Using parameters in markdown  
  Parameters (or R code in general) can be incorporated into markdown in two different ways. 

1. First, inline R code can be used to have markdown text depend on parameters. Here are two examples, for which you would swap the single quotes for backticks
    a. 'r if(params\$convert_cm) {"- Convert measurements from centemeters to inches"}'
    b. The package location is 'r params\$package_location'
2. Second, you can utilize the function the `knitr::asis_output` function to produce markdown text from within a code chunk. For this, you'll want to make sure the results are displayed as is, and the code itself is not shown in the knitted version.
```{r out.width = '40%', fig.align = 'center'}
knitr::include_graphics("images/parameterized-6.png")
```  

# Rmd Customizations
**Why customize?**

1. Make your results as pretty as possible before sharing
2. Make your resulting HTML file easy to navigate

# Interactive Plots
**Why interactive?**

1. Make your results as useful as possible before sharing
2. Questions can be answered more quickly with interactive results, for example:
    - Which observation is that outlier?
    - Can we zoom in on the section with a lot of overlapping points?
    - Can we look at only a particular range of x values?

# Publishing with Github Pages
**Why publish?**

1. Make your work publicly accessible (such as this tutorial!)
2. Share a web address with collaborators instead of a large number of files. Access can be limited to those with read access to GitHub repository.


```{r out.width = '40%', fig.align = 'center'}
knitr::include_graphics("images/github_pages-1.png")
```  


```{r out.width = '40%', fig.align = 'center'}
knitr::include_graphics("images/github_pages-2.png")
```  


